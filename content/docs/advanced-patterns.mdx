---
title: Advanced Patterns
description: Practical patterns for composing policies.
---

import { CodeBlock } from "fumadocs-ui/components/codeblock";

This section covers patterns commonly used in real applications.

---

## Layered Policies

You can layer middleware to separate concerns.

<CodeBlock>
```ts
createRail("admin", [
  requireAuth("/login"),
  requireRole("admin"),
  allowIf((ctx) => ctx.accountVerified),
]);
```
</CodeBlock>

Each middleware handles one responsibility.

- Authentication
- Authorization
- Additional constraints

Execution remains strictly sequential.

---

## Context Enrichment

Middleware can enrich context before later middleware runs.

<CodeBlock>
```ts
const attachPermissions = async (ctx) => {
  if (!ctx.user) return;

const permissions = await getPermissions(ctx.user.id);

return {
context: { permissions },
};
};

````
</CodeBlock>

Usage:

<CodeBlock>
```ts
createRail("billing", [
  requireAuth("/login"),
  attachPermissions,
  allowIf((ctx) => ctx.permissions?.canAccessBilling),
]);
````

</CodeBlock>

Returned `context` values are shallow-merged before the next middleware executes.

---

## Conditional Redirect Chains

Middleware can perform structured redirect flows.

<CodeBlock>
```ts
const onboardingRail = createRail("onboarding", [
  (ctx) => {
    if (!ctx.profile.completedProfile) {
      return {
        decision: { type: "redirect", to: "/onboarding/profile" },
      };
    }
  },
  (ctx) => {
    if (!ctx.profile.selectedPlan) {
      return {
        decision: { type: "redirect", to: "/pricing" },
      };
    }
  },
]);
```
</CodeBlock>

Only the first matching redirect executes.

---

## Feature Flags

Feature gating is straightforward.

<CodeBlock>
```ts
const featureRail = createRail("feature", [
  requireAuth("/login"),
  allowIf((ctx) => ctx.featureFlags?.newDashboard === true),
]);
```
</CodeBlock>

Feature flags remain external.
AuthRail evaluates them.

---

## Reusable Middleware Factories

Middleware can be parameterized.

<CodeBlock>
```ts
const requireFeature = (featureName: string) =>
  allowIf((ctx) => ctx.features?.[featureName] === true);
```
</CodeBlock>

Usage:

<CodeBlock>
  ```ts createRail("beta", [ requireAuth("/login"),
  requireFeature("betaAccess"), ]); ```
</CodeBlock>

---

## Composing Rails

You can evaluate one rail inside another if needed.

<CodeBlock>
```ts
const result = await adminRail.evaluate(ctx);

if (result.decision.type !== "allow") {
return result;
}

```
</CodeBlock>

Rails are plain objects in AuthRail, leaving composition to be explicit.
```
