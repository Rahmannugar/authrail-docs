---
title: Server Usage
description: Using the core engine in Node.js or server environments.
---

import { CodeBlock } from "fumadocs-ui/components/codeblock";

The AuthRail core engine is framework-neutral.

It can be used in:

- Node.js APIs
- Express middleware
- Serverless functions
- Edge runtimes
- Backend services

There are no React dependencies in the core evaluation logic.

---

## Basic Example (Node.js)

<CodeBlock>
```ts
import { createRail, requireAuth, requireRole } from "authrail";

const adminRail = createRail("admin", [
requireAuth("/login"),
requireRole("admin"),
]);

const result = await adminRail.evaluate({
user: req.user,
});

````
</CodeBlock>

Handle the decision:

<CodeBlock>
```ts
if (result.decision.type !== "allow") {
  return res.status(403).json({ error: "Forbidden" });
}

next();
````

</CodeBlock>

AuthRail emits a decision.
Your API decides how to respond.

---

## Express Example

<CodeBlock>
```ts
app.get("/admin", async (req, res) => {
  const result = await adminRail.evaluate({
    user: req.user,
  });

if (result.decision.type !== "allow") {
return res.status(403).send("Forbidden");
}

res.send("Admin panel");
});

````
</CodeBlock>

AuthRail acts as a policy engine across every environment.

---

## Sharing Policy Between Frontend and Backend

Because the core engine is framework-independent,
the same rail definition can be reused:

- In the frontend (React)
- In the backend (Node)
- In server-rendered environments

Example:

<CodeBlock>
```ts
// shared/policies.ts
export const adminRail = createRail("admin", [
  requireAuth("/login"),
  requireRole("admin"),
]);
````

</CodeBlock>

This allows consistent authorization logic across environments.
