---
title: Introduction
description: The type-safe policy engine for modern applications.
---

import { CodeBlock } from "fumadocs-ui/components/codeblock";

**<span className="text-fd-primary">Auth</span>Rail** is a deterministic, framework-agnostic policy engine built for the modern web. It allows you to define, test, and execute authorization logic with complete type safety.

[![npm version](https://img.shields.io/npm/v/authrail?style=flat-square)](https://www.npmjs.com/package/authrail)
[![npm downloads](https://img.shields.io/npm/dm/authrail?style=flat-square)](https://www.npmjs.com/package/authrail)

<div className="flex gap-2 items-center text-fd-primary">
  [**View NPM library**](https://www.npmjs.com/package/authrail)
</div>

Unlike traditional role-based access control (RBAC) systems that are often tightly coupled to database schemas or specific frameworks, AuthRail treats authorization as a pure function:

<CodeBlock title="Signature">
```ts
(Context) => Decision;
```
</CodeBlock>

You provide the context (user, resource, environment), and AuthRail provides the decision (`allow`, `deny`, or `redirect`).

## Why AuthRail?

Most authorization solutions are either too simple (boolean flags) or too complex (full-blown policy-as-code languages like Rego). AuthRail sits in the sweet spot:

- **Type-Safe**: Built with TypeScript first. Your context and rules are fully typed.
- **Sequential Evaluation**: Middleware runs in a defined order. No race conditions, no surprises.
- **Zero Magic**: No hidden state, no database calls, no side effects. You control the data.
- **Framework Agnostic**: Works in React, Next.js, Remix, Express, Cloudflare Workers, or generic Node.js.

## The Mental Model

Think of AuthRail as a series of gates (middleware) that a request must pass through. We call this chain a **Rail**.

1.  **Context**: You assemble the `Context` object (e.g., `user`, `request`).
2.  **Rail**: The context enters a `Rail` (a predefined list of checks).
3.  **Middleware**: Each middleware function inspects the context.
    - If it returns `deny` or `redirect`, execution stops immediately.
    - If it returns nothing, execution continues to the next middleware.
4.  **Decision**: If the context passes all checks, the final result is `allow`.

## Example

<CodeBlock title="example.ts">
```ts
import { createRail, requireAuth, requireRole } from "authrail";

// 1. Define a Rail
const adminRail = createRail("admin", [
requireAuth("/login"), // Stops here if not authenticated
requireRole("admin"), // Stops here if not an admin
]);

// 2. Evaluate
const result = await adminRail.evaluate({
user: currentUser,
path: "/dashboard/settings",
});

// 3. Act
if (result.decision.type === "redirect") {
return redirect(result.decision.to);
}

if (result.decision.type === "deny") {
throw new ForbiddenError();
}

//proceed to next defined context

```
</CodeBlock>

## What AuthRail is Not

- **Not an Authentication Provider**: We don't handle login, OAuth, or passwords. We work _with_ your existing auth (Clerk, Auth0, NextAuth).
- **Not a Database**: We don't store user roles or permissions. You pass them in via context.

Ready to build? Check out the [**<span className="text-fd-primary">Quick Start</span>**](/docs/quick-start) guide.
```
